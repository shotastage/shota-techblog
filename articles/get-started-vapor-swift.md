---
title: "VaporでサーバーサイドSwift入門・技術選定・理由編"
emoji: "📝"
type: "技術記事" # tech: 技術記事 / idea: アイデア
topics: ["vapor", "swift"]
publication_name: "magicapp"
published: false
---


現在、[MagicApp](https://mgq.app)ではSwift Vaporを使用したバックエンドの開発にトライしています。基本はKotlin + Springをベースとしつつも技術的なチャレンジングもあると非常に先駆的な価値を生み出せると考えたからです。
今回は、そんなMagicAppがVaporベースの本格的に運用するバックエンドを構築するまでの軌跡を記していこうと思います。


## 🤔 Server-side Swiftを導入する理由

Server-sideのアプリケーションは、半ばフレームワークありきで選択されることが多いです。例えば、Ruby on RailsやJava Springは王道ですし最近ですとPythonのDjangoなども人気です。
そんなかで、あえてSwift言語をサーバーサイドに採用する理由はなんでしょうか？また、どんな利点があるのでしょうか。

### 1️⃣ iOSエンジニアにとって扱いやすい

iOSエンジニアはSwift言語に精通しています。当然ですね。
もちろんSwiftは立派なオブジェクト指向型の構文を備えた言語ですので、SwiftエンジニアがRuby, Python, Javaが書けないということは恐らくないでしょう。
しかし、普段使い慣れた言語であれば開発スピードは当然早いわけです。


### 2️⃣ パフォーマンスが良い

SwiftはLLVMのコンパイラ基盤の上に構築されたネイティブコンパイルの言語です。RubyやPythonなどのインタプリタ型と比較するとオーバーヘッドが少なく高速な動作を期待できます。また、JavaやC#といったVMベースの言語と比較しても通常の運用と比較すると非常に少量のメモリ使用で多くのコネクションを維持・処理することができます。*1

また、SwiftNIOという非常に強力なネットワーキングライブラリは非同期イベント駆動（EventLoop）により少数のスレッドで大量の同時接続を高速に処理することができます。このSwiftNIOはJavaのNettyに似ていますがAOTコンパイルである点やメモリの解放ロジックがGCではなくARCであることも起因するのか非常に高速で動作します。

### 3️⃣ GoよりしっかりしていてRustほど厳密ではない

AOTコンパイルのプログラミング言語で軽量なバックエンドを作成するには競合としてGo言語による実装やRustのActix+Dieselなどの手段も依然としてありました。
Go言語はAOTのマイクロサービスを構築する代表的な事例であり確実性も高いものです。そして、Rustは高スループットなプログラムの代表例です。
しかし、MagicAppでは以下のような理由からこれらの選択肢をSwiftで実現することにしまた。

#### Go言語からSwiftの理由

Go言語は非常に軽量で高速なのが特徴です。あまり全面的には主張されませんがビルドが高速なのも現場のエンジニアとしては非常に助かるポイントです。
一方で、新しい言語としては異例の「None object-oriented」な言語でありC言語をモダンに楽に書けるようにした言語だと感じます。

さて、ここで大きな問題ですがGo言語はシンプルな構文故に覚えやすく生産性が高いという魅力はありましたが、あまりにもシンプルすぎるので`Nilチェック`
地獄が悩ましいポイントでした。

```go
func (r *Repo) FindUserByID(id string) (*User, error) {
	// ありがち: どこかが未初期化だと nil 参照が起きるので事前ガード
	if r == nil {
		return nil, Err("repo is nil")
	}
	if r.db == nil {
		return nil, Err("db is nil")
	}

	// 擬似: 実DBアクセスの代わり
	if id == "" {
		return nil, Err("empty id")
	}
	return &User{ID: id, Name: "Taro"}, nil
}
```


### もちろんデメリットはある。

iOSエンジニアがSwiftに精通してるから、Swiftでバックエンドを構築すれば全てが楽で良い！そう単純に問屋は下ろしません。
iOSエンジニアにとってもSwiftの慣れを活かせない場合もあります。

#### 1. macOS/iOS由来のフレームワーク、ライブラリが使えない

特定のプログラミング言語の慣れというのは、言語仕様だけではなく、その言語でよく使用されるライブラリやフレームワークの使い方を知っている。という部分も大きいですよね。

ただ、バックエンドサーバーは基本的にはLinux環境下で動かすことが多いのでiOS/macOS特有の資産を使用することはできません。macOS上でコンパイルできてもLinux向けビルドでエラーになってしまいます。従って、Swift Vaporを使用したバックエンド開発には自ずとLinuxについての基礎的な知識はiOSフロントエンジニアであっても要求されることになります。

#### 2. バックエンド開発の知識はそこそこ必要

ここが大きい肝になります。iOSフロントの開発とバックエンドの開発は必要とされるスキルや知識のドメインが異なります。
バックエンド開発ではデーターベースの取り扱いやセキュリティの知識は当然必要となります。iOSエンジニアがこれらの知識を知っている場合は多いですが、iOSエンジニアだから自ずと知っているわけではありません。

また、Vaporはまだまだ開発途上の新しいフレームワークであり**エコシステム**はRailsやSpringと比較して潤沢とは言えません。アノテーションをつければなんとなく組める段階にはないので、多くの処理を自分で書かなければなりません。従って、Webバックエンドフレームワークの中身でやってるとこを大まかには理解しておく必要があります。


## 環境構築

Swift+Vaporの開発環境は流石のSwiftだけあってmacOSであれば非常に簡単です。
Xcodeが未インストールの方は[AppStore](https://apps.apple.com/jp/app/xcode/id497799835?l=en-US&mt=12)からダウンロードし、Homebrewがない方は[こちら](https://brew.sh)からインストールをしてください。
それ以外はほぼ必要ありません。

今回は、以下のような環境で行いました。
| 環境 |  |
|:----|:--|
| Operating System | macOS Sequoia |
| Xcode            | 16.3          |


## プロジェクトの作成
### 1. VaporのToolboxをインストール

```shell
$ brew update && brew install vapor
```

### 2. Vaporプロジェクトの作成

```shell
$ vapor init
```




※1. JavaのGraalVMなどを使用してネイティブコンパイルした場合はこの限りではありませんが、「すべてのコードが正しくコンパイルできる」わけではないので依然として元からコンパイル型である利点は大きいと考えています。
